/* IMPORTANT: Multiple classes and nested static classes are supported */

/*
 * uncomment this if you want to read input.
//imports for BufferedReader
import java.io.BufferedReader;
import java.io.InputStreamReader;

//import for Scanner and other utility classes

*/

// Warning: Printing unwanted or ill-formatted data to output will cause the test cases to fail
import java.util.*;
import java.io.*;
class TestClass {
    public static void main(String args[] ) throws Exception {
    Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int q=sc.nextInt();
        int a[] = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = sc.nextInt();
        int height = (int) (Math.log(n) / Math.log(2)) + 2;
        int size = (int)Math.pow(2,height);
        int v[]=new int[size+1];
        Arrays.fill(v,Integer.MAX_VALUE);
        makeTree(a,v,0,n-1,0);

for(int i=0;i<q;i++)
{
    if(sc.next().charAt(0)=='q') {
        int l = sc.nextInt()-1;
        int r = sc.nextInt()-1;
        int ans = findMin(0, n - 1, l, r, 0, a, v);
        System.out.println(ans);
    }
    else {
        int k = sc.nextInt();
        int val = sc.nextInt();
        update(0, n - 1, k-1, 0, a, v, val);
    }
    }


    }

    private static void update(int l, int r, int i, int level, int[] a, int[] v, int k) {

        if(l==r && l==i)
        {
            v[level]=k;
            return;
        }
        if(l>r)
            return;

        int mid = (l+r)/2;
        makeTree(a,v,l,mid,level*2+1);
        makeTree(a,v,mid+1,r,level*2+2);
        v[level]=Math.min(v[level*2+1],v[level*2+2]);








    }

    private static int findMin(int i, int j, int l, int r, int level, int[] a, int[] v) {
    if(r<i || l>j)
    return Integer.MAX_VALUE;
if(l==i && r==j)
    return v[level];
if(i==j)
    return v[level];
int mid=(i+j)/2;
return Math.min( findMin(i,mid,l,r,level*2+1,a,v),findMin(mid+1,j,l,r,level*2+2,a,v));
    }

    private static void makeTree(int[] a, int[] v, int l, int r, int level) {
if(l==r)
{
    v[level]=a[l];
    return;
}
    if(l>r)
        return;

int mid = (l+r)/2;
makeTree(a,v,l,mid,level*2+1);
makeTree(a,v,mid+1,r,level*2+2);
v[level]=Math.min(v[level*2+1],v[level*2+2]);


    }


}
